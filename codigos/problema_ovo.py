# -*- coding: utf-8 -*-
"""Problema_OVO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ddm52YIjCgjnoCDl6pTtJK-wkioiH_8B
"""

import numpy as np
import pandas as pd

def generate_table_1():
    #Definimos los valores de t_i (de 1 a 46)
    t_values = np.arange(1, 47)

    #Ingresamos los valores de y_i manualmente
    y_values = np.array([-5.8000, -5.1590, -4.2320, -3.4130, -2.6960, -1.6750, 10, 10, 10, 10, 10, 10, 10,
        10, 10, 10, 0.5360, 0.4730, -0.0080, 0.2990, 0.2000, -0.2990, 0.0080, -0.0730, -0.5360, -0.5750,
        -0.5840, -0.5570, -0.4880, 0.0290, -0.2000, 0.0310, 0.3280, 1.0970, 1.1440, 1.6750, 2.2960, 3.4130,
        4.2320, 5.1590, 6.2000, 6.9610, 8.6480, 9.6670, 11.2240, 12.9250])

    #Verificamos que las longitudes de t_values y y_values sean las mismas
    if len(t_values) != len(y_values):
        raise ValueError("Las longitudes de t_values y y_values deben ser iguales.")

    #Creamos DataFrame con los resultados
    data = {'i': t_values,
            't_i': t_values,
            'y_i': y_values}

    #Convertimos los datos a un DataFrame
    table = pd.DataFrame(data)
    return table

def analyze_encased_functions(table, p, epsilon):
    #Recuperamos el valor de y_p para el índice p
    y_p = table.loc[table['i'] == p, 'y_i'].values[0]

    #Calculamos el intervalo I_{epsilon}
    lower_bound = y_p - epsilon
    upper_bound = y_p + epsilon

    #Identificamos los índices i con y_i dentro de I_{epsilon}
    enclosed_functions = table[(table['y_i'] >= lower_bound) & (table['y_i'] <= upper_bound)]['i'].tolist()

    return enclosed_functions

#Generamos la tabla original
table_1 = generate_table_1()

#Definimos parámetros
p = 1
epsilon = 0.8

#Ejecutamos el análisis
enclosed_functions_v3 = analyze_encased_functions(table_1, p, epsilon)

# Mostramos resultados
print(f"Funciones encerradas en I_{{epsilon}} para p = {p}, epsilon = {epsilon}:")
print(enclosed_functions_v3)