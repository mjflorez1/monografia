# -*- coding: utf-8 -*-
"""ovo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UbhosEWB106_fOCm_B9DIPvRi4l6uT6w
"""

# -*- coding: utf-8 -*-
"""Problema_OVO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ddm52YIjCgjnoCDl6pTtJK-wkioiH_8B
"""

import numpy as np
import pandas as pd
import random
import matplotlib.pyplot as plt

# Definimos el modelo cubico

def model(t,x1,x2,x3,x4):
    return x1 + x2 * t + x3 * t**2 + x4 * t**3

def f_i(ti,yi,x):
    return (model(ti,*x) - yi)**2


#Definimos los valores de t_i (de 1 a 46)
m = 47
t = np.linspace(-1,3.5,m)
xstar = np.array([0, 2, -3, 1])

y = 10 * np.ones(m)
random.seed(1234)

for i in range(6):
    y[i] = model(t[i],*xstar) + random.uniform(-0.01, 0.01)

for i in range(16,m):
    y[i] = model(t[i],*xstar) + random.uniform(-0.01, 0.01)

xk = np.ones(4)
faux = np.zeros(m)

for i in range(m):
    faux[i] = f_i(t[i],y[i],xk)

faux = np.sort(faux)

p = 40

fovo = faux[p-1]




# Definimos la función



# def analyze_encased_functions(table, p, epsilon):
#     #Recuperamos el valor de y_p para el índice p
#     y_p = table.loc[table['i'] == p, 'y_i'].values[0]

#     #Calculamos el intervalo I_{epsilon}
#     lower_bound = y_p - epsilon
#     upper_bound = y_p + epsilon

#     #Identificamos los índices i con y_i dentro de I_{epsilon}
#     enclosed_functions = table[(table['y_i'] >= lower_bound) & (table['y_i'] <= upper_bound)]['i'].tolist()

#     return enclosed_functions



#Definimos parámetros
p = 1
epsilon = 0.8

#Ejecutamos el análisis
enclosed_functions_v3 = analyze_encased_functions(table_1, p, epsilon)

# Mostramos resultados
# print(f"Funciones encerradas en I_{{epsilon}} para p = {p}, epsilon = {epsilon}:")
# print(enclosed_functions_v3)